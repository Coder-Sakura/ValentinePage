<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决pixiv登录机制添加Google V3验证]]></title>
    <url>%2Fblog%2F2019%2F08%2F29%2Fpixiv-new-login%2F</url>
    <content type="text"><![CDATA[说在前面的话 本篇概述：本文主要解决爬虫登录pixiv问题。8月份 pixiv 添加 recaptcha_v3(Google V3版本验证) 1、Google V3验证？ 何为 Google 验证码（reCAPTCHA v3）? reCAPTCHA v3 会以嵌入js的方式，给网站后台返回一个分数，这个分数是用于判断用户是否是机器人，分数的范围是0~1，分数约接近0，越像机器人； 2、使用之前文章中的代码模拟登录 Pixiv文章地址：Python爬虫-pixiv关注画师作品[1] 结果 json 数据格式化一下 ↓ 3、分析 我反复登录了几次，网页上并发现没有出现上图的 “I’m not a robot” 但是在登录抓包却看到 recaptcha_v3_token的值不为空，以前这个字段我记得是空的。 打开登录页面，f12打开调试工具–Network，点击XHR分页，可以看到每隔一段时间，通过 reload 重新请求一个 recaptcha_v3_token (稍微等待一下，一会儿就会看到第二个reload出来了) ↓ 登录的 from data，这个 recaptcha_v3_token ↓ 截个图，看看请求 recaptcha_v3_token 要 post 的字段 ↓ 4、解决方案1、手动抓包，在 headers 加入cookie 字段 图太长，手动省略 ↓ 2、selenium 抓取 （略） 个人比较喜欢用纯代码实现，虽然 selenium 也是要写代码。 3、selenium + requests (正文) [Warning]:该方法食用前，请先确保手动在 Chrome 上登录 pixiv selenium 自动保存 cookies requests 读取 cookies 并维持会话 Talk is cheap , Show me code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from selenium import webdriverimport osimport jsonimport requestsfrom requests.cookies import RequestsCookieJar# user data目录pro_dir = r'C:\Users\Hatsune Miku\AppData\Local\Google\Chrome\User Data'def get_cookie(): ''' 获取本地cookies ''' # 添加配置 chrome_options = webdriver.ChromeOptions() # 静默模式 chrome_options.add_argument('--headless') chrome_options.add_argument('--no-sandbox') chrome_options.add_argument('--start-maximized') # 添加user data目录 chrome_options.add_argument('user-data-dir='+os.path.abspath(pro_dir)) driver = webdriver.Chrome(chrome_options=chrome_options) # 访问后,获取cookies driver.get('https://www.pixiv.net/') cookies = driver.get_cookies() # 保存cookies with open("pixiv_cookies.txt", "w") as fp: json.dump(cookies, fp) driver.close()def read_cookie(): ''' 读取cookies ''' jar = RequestsCookieJar() with open("pixiv_cookies.txt", "r") as fp: cookies = json.load(fp) for cookie in cookies: jar.set(cookie['name'], cookie['value']) return jardef rep(jar): ''' 携带cookies对象并验证 ''' # 此为个人关注画师页面 url = 'https://www.pixiv.net/bookmark.php?type=user' headers = &#123; 'referer': 'https://accounts.pixiv.net/login', 'origin': 'https://accounts.pixiv.net', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; html = se.get(url,headers=headers,cookies=jar) return htmlif __name__ == '__main__': get_cookie() se = requests.session() # 定义session对象 jar = read_cookie() html = rep(jar) with open('bookmark.html','w+',encoding='utf8') as fp: fp.write(html.text) os.system('start bookmark.html') # 打开文件 结果展示 代码运行结束，会打开一个个人关注画师网页（selenium运行中的警报再想办法处理了） 可以将上面代码稍作修改，然后再封装成一个获取 cookies 对象的函数，后面直接携带这个 cookies 就行了 剩下的，想要拿收藏的插画√、关注的画师√、排行榜插画√ 都是可以的。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0613]]></title>
    <url>%2Fblog%2F2019%2F06%2F15%2Fpythondailyquestion-0613%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0612-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 从标准输入读取两个整数并打印两行，其中第一行输出两个整数的整除结果；第二行输出两个整数的带小数的除法结果。 123456print('exp:12 24')nums = input('input tow nums:')a,b = nums.split(' ')print(int(a)//int(b))print('%.2f'%(int(a)/int(b))) 2、基础题 使用turtle库，绘制一个风轮效果，其中，每个风轮内角为45度，风轮边长150像素。‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬提示：turtle.goto(x,y)函数，能够将turtle画笔移动到坐标(x,y) 3、提高题 列表中有一个数字出现的次数超过列表长度的一半，请找出这个数字。例如，输入一个长度为 9 的列表[1, 2, 3, 2, 2, 2, 5, 4, 2]。数字 2 出现了5次，超过列表长度的一半，因此输出2。如果不存在则输出0。 12345678910111213# 也可以自己指定数组,这里随机生成import randomlens = int(input('The len is :'))t = []for i in range(lens): t.append(random.choice(range(lens)))print('数组为',t)for i in list(set(t)): if t.count(i) &gt; lens//2: print(i)]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0612]]></title>
    <url>%2Fblog%2F2019%2F06%2F15%2Fpythondailyquestion-0612%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0612-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、概念题 请简述python中有哪些方式实现字符串格式化？ 12345a = 'hello'b = 'world'print(a,b)print('%s %s'%(a,b))print('&#123;&#125; &#123;&#125;'.format(a,b)) 2、基础题 温度的刻画有两个不同体系：摄氏度（Celsius）和华氏度（Fahrenheit）。‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬请编写程序将用户输入华氏度转换为摄氏度，或将输入的摄氏度转换为华氏度。‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬转换算法如下：（C表示摄氏度、F表示华氏度）‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ C = ( F - 32 ) / 1.8‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ F = C * 1.8 + 32‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬要求如下：‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬(1) 输入输出的摄氏度可采用大小写字母C结尾，温度可以是整数或小数，如：12.34C指摄氏度12.34度；‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬(2) 输入输出的华氏度可采用大小写字母F结尾，温度可以是整数或小数，如：87.65F指摄氏度87.65度；‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬(3) 输出保留小数点后两位，输入格式错误时，输出提示：输入格式错误；‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬(4) 使用input()获得测试用例输入时，不要增加提示字符串。 1234567891011121314def change(t): if t[-1].upper() == 'C': t = float(t[:-1])*1.8+32 print('%.2fF'%t) elif t[-1].upper() == 'F': t = float(t[:-1])-32/1.8 print('%.2fC'%t) else: print('格式错误') if __name__ == '__main__': # print('Exp:12.34C、87.65F') Temperature = input('The Temperature is:') change(Temperature) 3、提高题 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 1234567891011print('exp整数数组:123456')int_list = list(input('Input The Integer Array:'))even_list = [] # 偶数for i in int_list: if int(i)%2 == 0: int_list.remove(i) even_list.append(i)int_list.extend(even_list)print(int_list)]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0611]]></title>
    <url>%2Fblog%2F2019%2F06%2F14%2Fpythondailyquestion-0611%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0611-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 给定任意一个整数，打印出该整数的十进制、八进制、十六进制（大写）、二进制形式的字符串。 12345678910int_num = int(input('input the integer'))# 转二进制print('二进制形式为 : &#123;&#125;'.format(bin(int_num)))# 转八进制print('八进制形式为 : &#123;&#125;'.format(oct(int_num)))# 转十进制print('十进制形式为 : &#123;&#125;'.format(int(int_num)))# 转十六进制print('十六进制形式为 : &#123;&#125;'.format(hex(int_num).upper())) 2、基础题 给用户三次输入用户名和密码的机会，要求如下：‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 如输入第一行输入用户名为‘Kate’,第二行输入密码为‘666666’，输出‘登录成功！’，退出程序；‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 当一共有3次输入用户名或密码不正确输出“3次用户名或者密码均有误！退出程序。”。 1234567891011121314151617import sysadmin_username,admin_password = 'Kate','666666'count = 0while True: if count == 3: sys.exit() username = input('Input Your Username: ') password = input('Input Your Password: ') if all([username==admin_username, password==admin_password]): print('登录成功') sys.exit() else: print('用户名或密码错误\n') count += 1 3、提高题 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法 注：先后次序不同 算作是不同的结果 12345678# 递归,参考def jump(n): if n == 1 or n == 2: return n return jump(n-1) + jump(n-2)if __name__ == '__main__': print(jump(8))]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0610]]></title>
    <url>%2Fblog%2F2019%2F06%2F14%2Fpythondailyquestion-0610%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0610-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 恺撒密码是古罗马恺撒大帝用来对军事情报进行加解密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列中该字符后面的第三个字符，即，字母表的对应关系如下：‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 对于原文字符P，其密文字符C满足如下条件：C=(P+3) mod 26‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 上述是凯撒密码的加密方法，解密方法反之，即：P=(C-3) mod 26‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬ 假设用户可能使用的输入包含大小写字母a~zA~Z、空格和特殊符号，请编写一个程序，对输入字符串进行恺撒密码加密，直接输出结果，其中空格不用进行加密处理。使用input()获得输入。 123456789101112131415161718# 首先知道2个函数ord() # str -&gt; asciichr() # ascii -&gt; strord('a')# 97chr(ord('a'))# a# a位移1位# ord('a')=97，ord('b')=98chr(ord('a')+((98-97)+1)%26)# b# z位移1位# ord('a')=97，ord('z')=122chr(ord('a')+((122-97)+1)%26)# a 12345678910word = 'za %test' # 加密字符串offset = 3 # 偏移量target = ''for w in word: if 'a' &lt;= w &lt;= 'z': target += chr( ord('a') + ((ord(w)-ord('a')) + offset )%26 ) elif 'A'&lt;= w &lt;='Z': target += chr( ord('A') + ((ord(w)-ord('A')) + offset )%26 ) else: target += w 2、提高题 请实现一个函数用来找出字符串中第1个只出现1次的字符。例如：当从字符串中只读出前两个字符”go”时，第1个只出现次的字符是”g”。当从该字符串中读出前六个字符”google”时，第1个只出现1次的字符是“l”。 1234567import sysa = input('input the word:')for a1 in a: if a.count(a1) == 1: print('第一个只出现一次的字符为&#123;&#125;'.format(a1)) sys.exit()print('没有只出现一次的字符')]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(更新动图)Python爬虫-pixiv关注画师作品[3]]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2Fpixiv-three%2F</url>
    <content type="text"><![CDATA[说在前面的话 本篇概述：第二篇的续作，主要是各种图片类型的下载和文件夹创建； github地址、文中代码不一定能直接执行，粘贴过来可能缩进有问题。 1、分析——如何判断类型？ 单图 ↓ 多图 ↓ 动图 仔细观察就会发现： 单图 url : 56309403_p0_square1200.jpg，有p0；pageCount：1 多图 url : 56527887_p0_square1200.jpg，有p0；pageCount：3 动图 url : 57027347_square1200.jpg，无p0；pageCount：1 2、代码——匹配类型123456789101112131415161718def painter_picture(self): ''' 上次的code ''' if pageCount == 1: # 有p0 # 2016/05/23/19/25/26/57027442_p0 # 无p0 # 2016/05/23/19/18/47/57027347 if small_url[51:-15][-2:] == 'p0': print('作品类型：单图\n') self.img_single(small_url,folder_path,folder_id) # 单图 else: print('作品类型：动图\n') self.img_gif(folder_path,folder_id) # 动图 else: print('作品类型：多图\n') self.img_multi(small_url,folder_path,folder_id,pageCount) # 多图 PS：拼接 url 时不要问为啥这么麻烦，看这里 本篇记录的是自己刚学python爬虫第一个爬虫项目的代码，这篇的代码可以说是仅仅是为了实现功能写出来的。 现在也有想法要重构，重构好之后发篇完整的出来，不过没有那么快而已。 现在找到了作品的详细信息接口，后面再更新了，这里用的是之前的方法。 回首看自己2个月前的代码，一点都不优雅。o(╥﹏╥)o 3、分析——创建画师文件夹及作品文件夹 首先指定一个下载目录 下载目录下为每个画师创建一个文件夹，形如：{id}–{name} 画师文件夹下为每个作品创建一个文件夹，形如：{id} 4、代码——文件夹1、创建画师文件夹 此处解决了画师更改名字，会导致该画师所有作品重下。 具体看代码吧，解释也挺麻烦的 123456789101112131415161718# 执行 mkdir_painter() 应在 attention_html() 的 painter_information 循环中# self.father_folder = self.mkdir_painter(painter_id,name)def mkdir_painter (self,painter_id,name): name = re.sub('[\/:*?"&lt;&gt;|]','_',name) folder_name = painter_id + '--' + name # 画师改名字！会导致重下 for folder in os.listdir(self.path): if painter_id == folder.split('--')[0]: print(u'[名字叫&#123;0&#125;文件夹已存在！]'.format(folder_name)) father_folder = os.path.join(self.path,folder) os.chdir(father_folder) ##切换到目录 return father_folder print(u'[建了一个&#123;0&#125;文件夹！]'.format(folder_name)) father_folder = os.path.join(self.path,folder_name) os.makedirs(father_folder) os.chdir(father_folder) ##切换到目录 return father_folder 2、创建作品文件夹12345678910111213def mkdir_works(self,folder_id): folder_path = os.path.join(self.father_folder,folder_id) isExists = os.path.exists(folder_path) if not isExists: print(u'\n[在',self.father_folder,'下建了一个', folder_id, u'文件夹！]') os.makedirs(folder_path) os.chdir(folder_path) ##切换到目录 return folder_path else: print(u'\n[在',self.father_folder,'下已经有', folder_id, u'文件夹！]') os.chdir(folder_path) ##切换到目录 return folder_path 5、单图下载12345678910111213141516171819202122232425262728def img_single(self,small_url,folder_path,folder_id): work_name = folder_id + small_url[-4:] # p站的图片有jpg和png的，但是从works_url获取到的只有小图jpg的url jpg_judge_path = folder_path + '\\' + work_name png_judge_path = folder_path + '\\' + folder_id + '.png' # 判断是否是上次因为jpg不行而下载png的图片，如果是的话，expand_name 用 .png 替换进行比对是否重复 if os.path.exists(jpg_judge_path) == True and os.path.getsize(jpg_judge_path) != 58: # 判断jpg print(jpg_judge_path,'已存在且字节数不为58！') else: if os.path.exists(png_judge_path) == True and os.path.getsize(png_judge_path) != 58: # 判断png print(png_judge_path,'已存在且字节数不为58！') else: try: small_date = small_url[51:-15] #动图的small_url没有p0 head = 'https://i.pximg.net/img-original/img/' img_url = head + small_date + small_url[-4:] #.jpg img_html = self.request(img_url) self.down(img_html,work_name,jpg_judge_path) # time.sleep(2) if os.path.getsize(jpg_judge_path) == 58: print('&#123;&#125;格式不对，准备重下'.format(work_name)) img_url = head + small_date + '.png' img_html = self.request(img_url) self.down_conversion(img_html,folder_id,jpg_judge_path,png_judge_path) except: print(work_name,'下载失败') 6、多图下载1234567891011121314151617def img_multi(self,small_url,folder_path,folder_id,pageCount): for img_num in range(0,pageCount): work_name = folder_id + '-' + str(img_num) + small_url[-4:] jpg_judge_path = folder_path + '\\' + work_name if os.path.exists(jpg_judge_path) == True and os.path.getsize(jpg_judge_path) != 58: print(jpg_judge_path,'已存在且字节数不为58！') else: multi_url = 'https://www.pixiv.net/member_illust.php?mode=manga_big&amp;illust_id=' +folder_id + '&amp;page=' + str(img_num) self.headers['User-Agent'] = random.choice(self.user_agent_list) try: multi_html = self.request(multi_url) multi_html_soup = BeautifulSoup(multi_html.text, 'lxml') img_url = multi_html_soup.find('img')['src'] #要请求src的地址再写入 img_html = self.request(img_url) self.down(img_html,work_name,jpg_judge_path) except: print(work_name,'下载失败') 7、动图P站动图其实只是多个图片设置页面停留时间而已，所以需要我们手动合成。 1.在动图的源文件地址(是个 zip 文件)，里面有关于每个图片的 delay (也就是页面停留时间)和图片文件。2.下载 zip，解压，用 imageio 进行合成，指定合成 gif 的帧率为 delay 就行了 但是存在一个问题，有些动图的每个图片设置的页面停留时间不同，这就让人很难搞了 12345678910111213141516171819202122232425262728293031323334353637import imageio# from PIL import Image# 记得没有用到PIL,但防止意外,我就先放这里了# 获取压缩包网址zip_url = 'https://www.pixiv.net/ajax/illust/' +folder_id + '/ugoira_metazip_html = self.request(zip_urlzip_json = json.loads(zip_html.text)zip_originalSrc = zip_json["body"]["src"]# 计算帧率delay = 1/(zip_json["body"]["frames"][0]['delay']/1000) #80(ms)/1000 -&gt; 0.08(s)print('帧率:',delay)# 下载zipheaders['Referer'] = 'https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=' + folder_idgif_html = self.request(zip_originalSrc)zip_name = folder_id + '.zip'f = open(zip_name, 'ab')f.write(gif_html.content)f.close()# 解压zipf = zipfile.ZipFile(zip_name,'r') for file in f.namelist(): f.extract(file,".")f.close()print('解压完成')os.remove(zip_name) # 删除压缩包gif_name = folder_id + '.gif' # gif图片nameframes = [] # 用来存储要进行合成gif的图片files = os.listdir(folder_path) # 扫描当前作品目录下的文件print('开始合成')for image_num in range(1,len(files)): frames.append(imageio.imread(files[image_num]))imageio.mimsave(gif_name, frames, 'GIF', fps = delay) # 间隔print(folder_id,'动图下载完成！')# 删除解压出的图片for file in files: os.remove(file) 8、最后 鸽了挺久的，觉得大部分东西代码和实践都说得清楚，毕竟不是教程贴ヽ(ー_ー)ノ github地址、文中代码不一定能直接执行，复制粘贴的。]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0603]]></title>
    <url>%2Fblog%2F2019%2F06%2F04%2Fpythondailyquestion-0603%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0603-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 列表sent = [‘she’, ‘sells’, ‘sea’, ‘shells’, ‘by’, ‘the’, ‘sea’, ‘shore’]。编写代码执行以下任务：a. 输出所有 sh 开头的单词b. 输出所有长度超过 4 个字符的词 12sent = ['she', 'sells', 'sea', 'shells', 'by', 'the', 'sea', 'shore']print([s for s in sent if s.startswith('sh') and len(s)&gt;4]) 2、提高题 在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 123456789101112131415161718import randomx = []n = input('数组长度为:')# 1. 生成数组for i in range(int(n)): x.append(random.choice(range(n)))# 2. 生成数组while len(x) != n: x.append(random.choice(range(n))) if len(x) == n: break# 输出第一个重复的数字 for x1 in x: if x.count(x1) &gt;= 2: print('第一个重复的数字为',x1) break]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0530]]></title>
    <url>%2Fblog%2F2019%2F05%2F31%2Fpythondailyquestion-0530%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0530-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 设计一个复利计算函数invest（）它包含三个参数：amount（资金），rate（年利率），time（投资时间）。键盘输入每个参数后，输出结果：返回每一年的资金总额比如，amount = 10000 , rate = 8% ,time = 5 (复利计算公式原理自行百度) 12345678910def invest(): amount = int(input('input your amount:')) rate = float(input('rate is:')) time = int(input('your cycle is:')) for i in range(1,time+1): amount *= (1+rate) print('第&#123;&#125;年 : &#123;&#125;'.format(i,amount)) if __name__ == "__main__": invest() 2、提高题 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy则经过替换之后的字符串为We%20Are%20Happy。 123456# 1.print('We Are Happy'.replace(' ','%20'))# 2.import reprint(re.sub(r' ','%20','We Are Happy'))]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0529]]></title>
    <url>%2Fblog%2F2019%2F05%2F31%2Fpythondailyquestion-0529%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0529-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题12345809*x=800*x+9*x x代表的是两位数 8*x的结果为2位数 9*x的结果为3位数求x及809×x结果 代码如下： 1234for x in range(10,100): if (10&lt;=8*x&lt;=100) and (100&lt;=9*x&lt;=1000): print(809*x)# 9708 2、提高题 1.对文件”命运.txt”进行字符频次统计，并将所有字符按照频次高低排序，将排序后的字符及其频次输出到文件”命运-频次排序.txt” 字符包括中文、英文、标点等，但不包括空格和回车输出格式要求：(1)字符与频次之间采用冒号 ：分隔(2)一个字符一行，比如理:224斯:120卫:100 12345678910111213141516f = open(r'命运.txt','r')m = f.read().replace('\n','')target = &#123;&#125;for word in m: target[word] = target.get(word,0) + 1# print(target)# 排序target = sorted(target.items(),key=lambda x:x[1],reverse=True)with open('命运-频次排序.txt','w',encoding='utf8') as output: for tar,count in target: output.write('&#123;&#125;:&#123;&#125;\n'.format(tar,count))f.close() 命运.txt下载 链接：https://www.lanzous.com/b757208/ 密码：f0il]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PythonDailyQuestion-0528]]></title>
    <url>%2Fblog%2F2019%2F05%2F31%2Fpythondailyquestion-0528%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：0528-每日一问 Tipsgithub：https://github.com/Elegant-Smile/PythonDailyQuestion 1、基础题 从键盘输入4个数字，各数字采用空格分隔，对应为变量x0,y0,x1,y1。计算(x0，y0)和(x1,y1)两点之间的距离，输出结果保留1位小数。比如，键盘输入：0 1 3 5，屏幕输出：5.0 1234a = input('input your number:').split()x0,y0,x1,y1 = int(a[0]),int(a[1]),int(a[2]),int(a[3])target = float(((y0-y1)**2+(x0-x1)**2)**0.5)print(target) 2、提高题 键盘输入小明学习的课程以及考试分数信息，信息之间采用空格分隔，每个课程一行，空格回车结束录入，示例格式如下：数学 90语文 95英语 86物理 84生物 87输出得分最高和最低的课程名称、考试分数，以及所有课程的平均分(保留2位小数)格式如下：最高分课程是语文 95，最低分课程是物理 84，平均分是88.4 12345678910111213141516171819c_s_list = &#123;&#125; # class &amp; scoresum = 0 # 均值while True: a = input('input your class &amp;&amp; score:') if a == 'esc': for key,value in c_s_list.items(): print(key,value) sum += int(value) # 均值 max_min = sorted(c_s_list.items(),key=lambda s:s[1]) print('\n得分最高的课程名称:&#123;&#125;考试分数:&#123;&#125;'.format(max_min[-1][0],max_min[-1][1])) print('得分最低的课程名称:&#123;&#125;考试分数:&#123;&#125;'.format(max_min[0][0],max_min[0][1])) print('均值:%.1f'%(sum/len(c_s_list))) break else: b = a.split() c_s_list[b[0]] = b[1]]]></content>
      <categories>
        <category>每日一问</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS模块实战-1-目录统计]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2Fos-mo-kuai-shi-zhan-1%2F</url>
    <content type="text"><![CDATA[说在前面的话 本篇概述：OS模块实战-1-目录统计 1、目录统计 指定一个路径，能计算出该目录的大小 2、Code123456789101112131415161718import os,datetime def get_dir_size(dir): size = 0 a = datetime.datetime.now() for root, dirs, files in os.walk(dir,topdown =False): size += sum([os.path.getsize(os.path.join(root, name)) for name in files]) b = datetime.datetime.now() print('扫描时间为: &#123;&#125;s'.format((b-a).seconds)) return sizeif __name__ == '__main__': # 目录可自己指定 size = get_dir_size('D:/test/test') if size/1024/1024 &gt; 1024: print('Total size is: %.3f Gb'%(size/1024/1024/1024)) else: print('Total size is: %.3f Mb'%(size/1024/1024)) 3、补充 主要是os.walk() 1、os.walk()1、基本介绍123os.walk(dir,topdown =True)# dir -- 目录# topdown -- 可选.True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。 123456# os.walk()返回三元元组(root,dirs,files)# 当前目录，当前目录的文件夹，当前目录的文件for root,dirs,files in os.walk('.') print(root,dirs,files) # 依次打印上述所说的 # 从而实现文件夹里的递归 2、性能比较12345678'''28936个文件和文件夹os.walk(dir,topdown =True) ——&gt; 7s ——&gt; 55.885GBos.walk(dir,topdown =True) ——&gt; 10次 ——&gt; 78.2s(整个程序运行时间)os.walk(dir,topdown =False) ——&gt; 5s ——&gt; 55.885GBos.walk(dir,topdown =False) ——&gt; 10次 ——&gt; 65.0s(整个程序运行时间)''']]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之OS]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2Fmodel-os%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：os模块常用方法汇总 os模块——操作系统的接口12import osdir(os) 1、os.listdir(path)☆123# 如果path=None,则返回当前目录下的文件夹和文件名字的列表;否则返回指定path的件夹和文件名字的列表os.listdir()os.listdir(path) 2、os.chdir(path)☆12# 切换到pathos.chdir(path) 3、os.getcwd()☆1os.getcwd() 4、os.path.join()☆12345# 拼接路径path1 = 'C:\\Users\\Hatsune Miku\\Desktopath2 = 'test1.py'os.path.join(path1,path2)# C:\\Users\\Hatsune Miku\\Desktop\\test1.py 5、os.path.exists(path)☆1234# 判断路径是否存在,返回True或Falseos.path.exists('.')os.path.exists('.\\ssss')# True False 6、os.path.abspath(path)☆12345# 返回path的绝对路径。os.path.abspath('.') # 返回当前目录# C:\\Users\\Hatsune Miku\\Desktopos.path.abspath('.\\1102')# 'C:\\Users\\Hatsune Miku\\Desktop\\1102 7、os.path.split(path)☆123456789# 将路径分解为文件夹和文件名,返回的是元组os.path.split('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# ('C:\\Users\\Hatsune Miku\\Desktop', 'test1.py')# 仅分离文件夹路径时需要注意的是,所以需要在文件夹后加上/os.path.split('C:\\Users\\Hatsune Miku\\Desktop\\')os.path.split('C:\\Users\\Hatsune Miku\\Desktop')# ('C:\\Users\\Hatsune Miku\\Desktop', '')# ('C:\\Users\\Hatsune Miku', 'Desktop') 8、os.path.dirname(path)☆123# 返回path中的文件夹部分，结果不包含'\',返回的是stros.path.dirname('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# C:\\Users\\Hatsune Miku\\Desktop 9、os.path.basename(path)☆123# 返回path中的文件名部分os.path.basename('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# test1.py 10、os.path.getmtime(path)123# 文件夹或文件的最后修改时间，返回的是从新纪元到访问时的秒数os.path.getmtime('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# 1556017564.1900363 11、os.path.getatime(path)123# 文件夹或文件的最后访问时间os.path.getmtime('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# 1555867584.470328 12、os.path.getacime(path)123# 文件夹或文件的创建时间os.path.getatime('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# 1555867584.470328 13、os.path.getsize(path)☆123456789# 文件夹或文件的大小，若是文件夹返回0,是文件则返回字节数os.path.getsize('C:\\Users\\Hatsune Miku\\Desktop\\test1.py')# 2419# 46.6M的文件,字节数为48877195print(48877195/float(1024*1024))print('%.2f'%(48877195/float(1024*1024)))# 46.61292552947998# 46.61 14、os.makedirs()☆12# 创建文件夹os.makedirs('C:\\Users\\Hatsune Miku\\Desktop\\testtesttest') 15、os.system()1234# 运行sheel命令,无返回值os.system('ipconfig')a = os.system('ipconfig')# 0 16、os.popen()123456# 执行命令并把 执行的cmd的输出结果 返回# os.popen(cmd,mode,bufsize) 命令,权限,需要的缓冲大小a = os.popen('ipconfig')a.read()# a 返回一个文件描述符号为fd的打开的文件对象# a.read()是字符串 17、os.remove(path)☆12# 删除文件路径os.remove(path) 18、os.rename(src,dst)12# 将文件或目录src重命名为dst# 将'tess1'文件夹重命名为'test2' 19、os.getenv()12# 获得环境变量os.getenv('path') 20、os.walk()1234567891011121314151617181920212223242526# os.walK()是一个简单易用的目录遍历器,用于在目录树中游走输出在目录中的文件名# 返回的是一个三元元组,(root,dirs,files)# root 当前遍历的目录路径# dirs 当前目录下的文件夹(列表)# files 当前目录下的文件(列表)# .代表当前目录路径for root,dirs,files in os.walk('.'): print(root) print(dirs) print(files) # 先返回当前目录的三元元组,再返回子目录的,有子子目录则亦然 # 计算一个文件夹的大小 ↓ # 首先遍历当前目录然后是子目录 # 遍历目录时可以先通过os.path.join拼接路径,用os.path.getsize()获得文件的大小,使用遍历则获得一个文件夹下的所有文件的大小——&gt;即这个文件夹的大小 # 1.size = 0for root,dirs,files in os.walk(path): for name in files: size += os.path.getsize(os.path.join(root, name)) # 2.size = 0for root,dirs,files in os.walk(path): size += sum([os.path.getsize(os.path.join(root, name)) for name in files])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Others-你相信这个世界能加速吗？]]></title>
    <url>%2Fblog%2F2019%2F04%2F25%2Frang-xia-zai-su-du-de-dao-jie-fang%2F</url>
    <content type="text"><![CDATA[说在前面的话 本篇概述：重新整理了一下关于度盘的黑科技 整理的时候发现 度盘下载器 的作者不维护了╮(╯▽╰)╭，今天也换了多个文件试了下貌似都是HTTP响应超时字样，详见https://www.linesoft.top/archives/4/ 毕竟也是陪伴多年的好朋友，献上一朵❀❀(绝对不是因为其他3作更好用一点的原因) 那么以下3作推荐给大家 加速世界——你相信这个世界能加速吗？加速通道 1加速通道 2加速通道 3proxyee-down 简介：Proxyee Down 是一款开源的免费 HTTP 高速下载器，底层使用netty开发，支持自定义 HTTP 请求下载且支持扩展功能，可以通过安装扩展实现特殊的下载需求。使用手册 预览： github地址：github 直接下载地址(建议看一遍使用手册)：地址 PanDownload 简介：百度盘第三方下载工具 预览： 地址：PanDownload 密码：co50 SpeedPan 简介：SpeedPan又名速盘，一款百度网盘满速下载工具利器 预览： 地址：SpeedPan 密码：7rn6]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Mysql基本使用]]></title>
    <url>%2Fblog%2F2019%2F04%2F22%2Fpy-mysql%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：python连接mysql的一些操作，欢迎指错 1、MySQLdbpython连接mysql用的模块。MySQLdb主要还是聚焦于如何和数据库进行连接和进行基本的操作，操作的体现形式主要还是进行SQL语句的执行。 安装 1pip3 install mysqlclient 2、基本使用1、数据库连接123456import MySQLdb# 连接数据库 ——&gt; 主机host,端口,用户,密码,数据库,编码conn = MySQLdb.connect(host='localhost',port=3306,user='你的账号',passwd='你的密码',db='你要操作的数据库',charset='utf8')# 连接成功后,创建一个游标对象用于操作数据库# 获取到游标后再进行数据库操作cur = conn.cursor() 2、查询12345678910111213141516171819202122# 查询cur.execute("SELECT VERSION()") # 这里不返回结果，只是执行version = cur.fetchall()# 返回的是元组 (('5.7.14',),)# fetchall() 是返回所有匹配的元组,接收全部的返回结果行# fetchone() 只返回一个匹配的元组,然后游标后移# 我这里用了自己数据库中的一个表演示fetchall()和fetchone()# 1. fetchall()cur.execute("SELECT * from test")a = cur.fetchall()print(a,len(a))# 这里数据量太大,结果就不放出来了# 2. fetchone()cur.execute("SELECT * from test")data = cur.fetchone()i = 0while i&lt;10: print(data) i += 1 data = cur.fetchone() 附图 3、插入12345678910111213141516171819202122232425262728# 插入# sql语句,%s占位sql = "INSERT INTO test(date,tag,title,link) VALUES(%s,%s,%s,%s)"# 1. 插入一条execute() data是元组data = ('19/02/14', 'Android', 'Android\xa0fdget()\xa0优化导致的\xa0binder\xa0UAF\xa0漏洞（CVE-2019-2000）\xa0：', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1719')try: cur.execute(sql,data) # 事务commit后才会真正插入数据 conn.commit()except Exception,e: # 出错回滚 conn.rollback()finally： cur.close() conn.close() # 断开数据库连接 # 2. 批量插入executemany()datas = [('19/02/14', 'Android', 'Android\xa0fdget()\xa0优化导致的\xa0binder\xa0UAF\xa0漏洞（CVE-2019-2000）\xa0：', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1719'),('19/02/14', 'IoTDevice', '以家庭路由为例讲解 IoT 逆向工程：', 'http://va.ler.io/myfiles/dva/iot-rev-engineering.pdf')]try: cur.executemany(sql,datas) conn.commit()except Exception,e: # 出错回滚 conn.rollback()finally: cur.close() conn.close() # 断开数据库连接 4、修改，更新12345678910# sqlsql = "UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'" % ('M')try: cur.execute(sql) conn.commit()except: conn.rollback()finally: cur.close() conn.close() 5、删除12345678910# sql 删除数据,年龄大于20sql = "DELETE FROM EMPLOYEE WHERE AGE &gt; %s" % (20)try： cur.execute(sql) conn.commit()except: conn.rollback()finally: cur.close() conn.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫/GUI编程之签名生成器]]></title>
    <url>%2Fblog%2F2019%2F04%2F19%2Fsignature-generator%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：主要记录爬虫+GUI制作签名生成器 1、爬虫实现 暂时留空，本篇先解析代码 2、GUI实现 暂时留空，本篇先解析代码 3、代码github地址：https://github.com/Coder-Sakura/Signature-generator 1. uustv.py ——&gt; 爬虫模块点我可以将内容伸缩哦~ ٩(๑&gt;◡&lt;๑)۶ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import requestsimport timefrom bs4 import BeautifulSoupfrom tkinter import messageboxfrom tkinter import * # PhotoImageclass Spider(object): # 初始化,包括请求头,url,支持的字体、字号,需要生成签名的文字 def __init__(self): self.headers = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36', &#125; self.url = 'http://m.uustv.com/' self.values = ['个性签','连笔签','潇洒签','草体签','合体签','商务签','可爱签'] self.font = ['jfcs.ttf','qmt.ttf','bzcs.ttf','lfc.ttf','haku.ttf','zql.ttf','yqk.ttf'] self.v_f = dict(zip(self.values,self.font)) self.word = '' self.fonts = '' self.size = 60 # 接受GUI页面传来的参数,首先检查是否为空,其次是选择的字体大小 def check(self,part,enter,numberChosen,sizesChosen): self.part = part self.word = enter.get() self.fonts = numberChosen.get() # 文字 self.size = sizesChosen.get() if not enter.get(): messagebox.showinfo('提示','请输入需要生成签名的文字') else: if self.fonts in self.v_f: self.fonts = self.v_f[self.fonts] # 文字转换成字体格式名称 # messagebox.showinfo('提示',word) # messagebox.showinfo('提示',fonts) self.post_img() # 发送请求,获取图片地址,并捕获图片数据返回 def post_img(self): data = &#123; 'word': self.word, 'sizes': self.size, 'fonts': self.fonts, 'fontcolor': '#000000'&#125; html = requests.post(url=self.url,data=data,headers=self.headers) html_soup = BeautifulSoup(html.text,'lxml') img_url = self.url + html_soup.find('div',attrs=&#123;'class':'tu'&#125;).find('img')['src'] print(img_url) img_html = requests.get(url=img_url,headers=self.headers) img_html.encoding = 'utf8' self.down(img_html) # 下载图片 def down(self,img_html): f = open('&#123;&#125;.gif'.format(self.word),'wb') f.write(img_html.content) f.close() self.view_img() # 将图片展示到GUI页面 def view_img(self): image = PhotoImage(file='&#123;&#125;.gif'.format(self.word)) label2 = Label(self.part,image=image) label2.bm = image label2.grid(row=3,columnspan=2) 2. uustv_gui.py点我可以将内容伸缩哦~ ٩(๑&gt;◡&lt;๑)۶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445from tkinter import *from tkinter.ttk import Comboboxfrom uustv import *class GUI(object): def __init__(self): self.window_title = '签名生成器--网络精英--2019.04.12' self.label_text = '输入签名字样' self.button_text = '点击生成' self.values = ['个性签','连笔签','潇洒签','草体签','合体签','商务签','可爱签'] self.sizes = [10,20,30,40,50,60,70] # GUI def parts(self): # 部件 part = Tk() # 封装对象 part.title(self.window_title) # 标题 part.geometry('545x330') # 窗口大小 # 定义label,文字区域,只能看不能点,设置文字，文字字体和文字大小 label1 = Label(part,text='设计字样',font=('华文行楷',20)) label1.grid() # 定义布局格式，grid()表示网格格式 # 输入框 enter = Entry(part,font=('微软雅黑',20)) enter.grid(row=0,column=1) # 字体样式选择 numberChosen = Combobox(part, width=12, state='readonly') numberChosen['values'] = self.values numberChosen.current(0) numberChosen.grid(row=1,column=0) # 字体大小选择 sizesChosen = Combobox(part, width=12, state='readonly') sizesChosen['values'] = self.sizes sizesChosen.current(5) sizesChosen.grid(row=1,column=1) # 按钮,当按下按钮时,携带参数至指定函数 button = Button(part,text='点击生成',font=('微软雅黑',20),command=lambda: Spider().check(part,enter,numberChosen,sizesChosen)) button.grid(row=2,column=0) part.mainloop()gui = GUI()gui.parts() 3. 生成软件123456789# 1.首先安装pyinstallerpip3 install pyinstaller# 2.在2个py的所在目录调出cmd，输入以下命令:pyinstaller -F -w uustv.py uustv_gui.py# 在生成的文件夹中找到dict文件夹,其下有exe文件,便是最终的签名生成器# 3.如果需要自定义软件图标,需要自己准备好适当尺寸的ico格式图片# 打包的时候使用-i xxx.ico 来指定自定义的ico图标]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫-pixiv关注画师作品[2]]]></title>
    <url>%2Fblog%2F2019%2F03%2F30%2Fpixiv-two%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：上篇的后续；主要是分析数据接口，拿到关注画师的所有作品的详细信息 1、分析——关注界面 关注界面(默认公开) https://www.pixiv.net/bookmark.php?type=user&amp;rest=show 这里关注画师全在公开界面，虽然非公开获取也是ok的 公开和非公开只是，https://www.pixiv.net/bookmark.php?type=user&amp;rest=show 后面分别是rest=show 和 rest=hide F12 查看 Elements ，寻找画师列表和页数 画师列表全在一个 class=members 的 div 中 画师信息在user-data中，有作者 id、主页 url、作者 name 最大页数在一个 class=_pager-complex 的 div，倒数第二个li 2、代码——bs4匹配1234# 找到最大页数max_num = attention_html_soup.find('div', attrs=&#123;'class', '_pager-complex'&#125;).find_all('li')[-2].text # 画师个人信息painter_information = attention_html_soup.find('div', attrs=&#123;'class', 'members'&#125;).find_all('div', attrs=&#123;'class', 'userdata'&#125;) 3、代码——获取关注画师的信息123456789101112131415161718192021#获取关注画师界面的信息def attention_html(self): # self.return_to = 'https://www.pixiv.net/bookmark.php?type=user&amp;rest=show&amp;p=' # p 是页数 attention_html = self.request(self.return_to) attention_html_soup = BeautifulSoup(attention_html.text, 'lxml') #获取最大页数 max_num = attention_html_soup.find('div', attrs=&#123;'class', '_pager-complex'&#125;).find_all('li')[-2].text print('最大页数为%s' % (max_num)) for num in range(1,int(max_num)+1): attention_html_url = self.return_to + str(num) # 构造每个页面的 url attention_html = self.request(attention_html_url) attention_html_soup = BeautifulSoup(attention_html.text,'lxml') painter_information = attention_html_soup.find('div', attrs=&#123;'class', 'members'&#125;).find_all('div', attrs=&#123;'class', 'userdata'&#125;) #画师个人信息 for painter in painter_information: # userdata下的a标签中的data-user_id = 作者id painter_id = painter.a['data-user_id'] # userdata下的a标签中的data-user_name = 作者name name = painter.a['data-user_name'] print('&#123;0&#125;:&#123;1&#125;'.format(name,painter_id)) print('已获取所有关注画师的作品信息！！！！') 对于文笔不好的人来说，还是上代码来的舒服 毕竟 talk is cheap, show me code ! 4、分析——画师个人主页及数据流向 这里说下，为什么不获取 user-data 里面的 href 属性？ 正常流程不应该是拿到 href 然后访问 url，获取源码，然后拿到作品信息。 原因是：这里用的是Ajax请求，所以源码中并没有我们想要的数据 我们可以直接通过接口拿到这个画师的所有作品的数据。 该画师有73个作品，但是点击进入主页发现只有小小的一部分 勾上 Preserve log，点击查看全部 新加载的页面显示了所有的作品（虽然分为2页） 与之前的 XHR 比较，接下来的目标在红框标出来的三个文件（不一定全是我们的目标） 点击第一个illust，发现 Preview 里是标签 tags （json数据） 点击第二个illust，Preview 里是作品信息 （json数据） 确定了第二个 illust 是目标之后，模仿它进行请求 但是发现他的 url 是一串巨长的字符串，由 一页的所有作品 id 和 is_manga_top=0 拼接而成 url 中作品 id 的拼接顺序是由新到旧（也就是数字大的在前面） 1url = https://www.pixiv.net/ajax/user/1117751/profile/illusts?ids%5B%5D=73742388&amp;ids%5B%5D=71855085&amp;ids%5B%5D=71849582&amp;ids%5B%5D=71685985&amp;ids%5B%5D=68213121&amp;ids%5B%5D=67765964&amp;ids%5B%5D=67758280&amp;ids%5B%5D=67757922&amp;ids%5B%5D=67619936&amp;ids%5B%5D=67404010&amp;ids%5B%5D=66856979&amp;ids%5B%5D=65998170&amp;ids%5B%5D=65834643&amp;ids%5B%5D=65393332&amp;ids%5B%5D=63861794&amp;ids%5B%5D=63761535&amp;ids%5B%5D=63617575&amp;ids%5B%5D=63475838&amp;ids%5B%5D=63090307&amp;ids%5B%5D=62347061&amp;ids%5B%5D=62200016&amp;ids%5B%5D=62178209&amp;ids%5B%5D=61785521&amp;ids%5B%5D=61656195&amp;ids%5B%5D=61489588&amp;ids%5B%5D=60732958&amp;ids%5B%5D=60588424&amp;ids%5B%5D=60384884&amp;ids%5B%5D=59959669&amp;ids%5B%5D=59706889&amp;ids%5B%5D=59656129&amp;ids%5B%5D=59541311&amp;ids%5B%5D=59180046&amp;ids%5B%5D=58977788&amp;ids%5B%5D=58919004&amp;ids%5B%5D=58029173&amp;ids%5B%5D=57027442&amp;ids%5B%5D=57027347&amp;ids%5B%5D=56527887&amp;ids%5B%5D=56525716&amp;ids%5B%5D=56309403&amp;ids%5B%5D=56110382&amp;ids%5B%5D=55934890&amp;ids%5B%5D=55680445&amp;ids%5B%5D=54917440&amp;ids%5B%5D=54900477&amp;ids%5B%5D=54900429&amp;ids%5B%5D=54900380&amp;is_manga_top=0 下一步目标：既然有所有作品 id 拼接成的 id ，说明是有接口获取所有作品 id 的。 5、模仿请求 在 XHR 中继续寻找，发现一个叫 all 文件，点开 Preview （json数据） all 的 Request URL: https://www.pixiv.net/ajax/user/1117751/profile/all ，/user/后面的数字是作者的 id 在 Preview 中发现 illusts (插画)属性 ，下面的应该就是作品 id 了，可以自己复制一个去验证一下。 补充：有些画师在 manga (漫画)属性也是有值的，所以这里需要和前面的 illusts 属性合并 Request URL 放到浏览器中去访问，将访问结果复制到 json.cn 进行格式化 6、代码——获取关注画师的所有作品信息 获得关注画师的信息，比如 id、name 通过 https://www.pixiv.net/ajax/user/[画师id]/profile/all 来获取画师的所有作品 id （单图 动图 多图 都在 illusts 属性中，漫画虽然是单图和多图，但在 manga属性 中） 接着通过构造作品 id 和 is_manga_top=0 的 url 去请求作品的详细信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 获取关注画师界面的信息def attention_html(self): # self.return_to = 'https://www.pixiv.net/bookmark.php?type=user&amp;rest=show&amp;p=' # p 是页数 attention_html = self.request(self.return_to) attention_html_soup = BeautifulSoup(attention_html.text, 'lxml') # 获取最大页数 max_num = attention_html_soup.find('div', attrs=&#123;'class', '_pager-complex'&#125;).find_all('li')[-2].text print('最大页数为%s' % (max_num)) for num in range(1,int(max_num)+1): attention_html_url = self.return_to + str(num) # 构造每个页面的 url attention_html = self.request(attention_html_url) attention_html_soup = BeautifulSoup(attention_html.text,'lxml') painter_information = attention_html_soup.find('div', attrs=&#123;'class', 'members'&#125;).find_all('div', attrs=&#123;'class', 'userdata'&#125;) #画师个人信息 for painter in painter_information: # userdata下的a标签中的data-user_id = 作者id painter_id = painter.a['data-user_id'] # userdata下的a标签中的data-user_name = 作者name name = painter.a['data-user_name'] print('&#123;0&#125;:&#123;1&#125;'.format(name,painter_id)) # 构造url来获取作者的所有作品 id ajax_url = 'https://www.pixiv.net/ajax/user/&#123;0&#125;/profile/all'.format(painter_id) self.painter_picture(painter_id,ajax_url,name) print('获取所有关注画师信息完成！！！！') # 执行 painter_picture() 应在 attention_html() 的 painter_information 循环中# self.painter_picture(painter_id,ajax_url,name)def painter_picture(self,painter_id,ajax_url,name): ajax_html = self.request(ajax_url) # 使用json.loads()方法加载进来 ajax_json = json.loads(ajax_html.text) ajax_illusts = ajax_json["body"]["illusts"] ajax_manga = ajax_json["body"]["manga"] # 判断是否有 manga 类型的作品 if len(ajax_manga) == 0: total_data_dict = dict(ajax_illusts) else: # 合并 manga 和 illusts,并转换为字典 total_data_dict = dict(ajax_illusts, **ajax_manga) # 字典格式：id:None,所以取字典的keys，并转化为list total_data = list(total_data_dict.keys()) # 这里为什么要排序呢？ # 返回的json里id是从小到大,我们只要[::-1]反转,不就大到小了吗？ # 但是有些画师的作品是有分illusts和manga的，大概就是普通作品(单、多、动)和漫画类型 # 为了防止没拿到漫画类型作品的id,我使用dict(,**)来合并字典 # 这样做是追加到前一个字典的尾部,所以我们必须排序才能正确请求到每一页的48个作品 # 这里用的是冒泡排序（从小到大），刚好学到就用了 for x in range(len_total-1): for y in range(len_total-1-x): if total_data[y] &gt; total_data[y+1]: total_data[y],total_data[y+1] = total_data[y+1],total_data[y] # 从大到小排序的作品id total_data = total_data[::-1] # 按每48个分组,画师每页显示48个作品 limit_num = 48 # after_grouping_list = [[xxx,xxx,xxx],[48个id],[...]...] after_grouping_list = [total_data[i:i+limit_num] for i in range(0,len(total_data),limit_num)] print('画师',name,'作品有：',len(after_grouping_list),'页') # 开始根据作品id来拼接url（就是那个一大串的url） count = 0 # 每拼接完48个+1 for grouping_list in after_grouping_list: ids_big = 'https://www.pixiv.net/ajax/user/&#123;&#125;/profile/illusts?'.format(painter_id) for work_id in grouping_list: ids = 'ids%5B%5D=' + work_id + '&amp;' ids_big = ids_big + ids works_url = ids_big + 'is_manga_top=0' count += 1 print('第%s页的works_url:%s' % (count,works_url)) # 发起请求获得第count页作品的详细信息 works_html = self.request(works_url) works_json = json.loads(works_html.text) works_data = works_json["body"]["works"].values() for x in works_data: title = x['title'] folder_id = x['id'] tags = x['tags'] small_url = x['url'] pageCount = x['pageCount'] print('\n作品id:&#123;0&#125;\t作品页数:&#123;1&#125;'.format(folder_id,pageCount)) print('作品标题:&#123;0&#125;'.format(title)) print('作品标签:&#123;0&#125;'.format(tags)) print('作品250*250图片地址:&#123;0&#125;'.format(small_url)) works_data = works_json[“body”][“works”].values() 因为 keys() 是作品 id，values() 里面也有，所以直接 values() 就好了 7、最后 本篇主要是分析数据接口，拿到关注画师的所有作品的详细信息 那么下篇再根据单图动图多图进行图片下载，预计文件存储、其他的小功能和最后的代码汇总得放在下下篇了。 へ(￣ ￣;へ)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫-pixiv关注画师作品[1]]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2Fpixiv-one%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：大概有几篇是关于pixiv关注画师的作品抓取的思路和代码，后面大概还会有p站个人收藏的爬虫（这个比较简单） 1、pixiv介绍 Pixiv 这是一个墙外的网站，需要正确的扶梯姿势和科学上网 当然也可以参考我的方法（nginx + 修改 hosts 文件） 地址：点击前往 密码:3235 (建议 hosts 文件取自己需要的那部分) 为什么选 pixiv 呢？其实在12月份的时候我刚开始学 python，这个 pixiv 的小项目是我自己突发奇想要做的，那时候是新年前一周左右，对于那时候的我来说，pixiv 反爬难度一般般，但比较难的数据接口分析、构造url、文件操作、代理、图片合成等（自己一个人盯了这个网站几天，最后完成超级兴奋！） nginx+host上P站教程——2019.5.24更新 下载上面链接中的压缩包，解压 复制hosts文件中的代码，追加到当前电脑的hosts文件中 当前电脑的hosts文件在C:\Windows\System32\drivers\etc目录下，如果没找到的话可以搜索一下或者用everything软件（强烈建议!)进行搜索. 打开调试工具（这个功能全）.bat 选择对应的数字序号 Tip 如果正常启动不行的话，可以尝试以下代码 123netstat -aon | findstr ":443"# 找到占用了443端口的程序的PID# 可能是本机虚拟机占用了这个端口 或者手动修改nginx的端口，具体修改流程百度 2、Target 登录账号关注的画师的作品 思路： 首先是模拟登录（PC 用过 pixiv 的同学都知道在未登录的时候 pixiv 会对用户做一些限制，所以我们要先模拟登录） 其次保持会话连接（可以考虑 cookie 保存，这里采用的是 requests 的 session 会话连接） （基于图片网站，可能是动态加载，那么需要分析接口或者是 selenium 模拟） 最后才进行网页内容分析，然后抓取保存下来 3、登录模拟实现流程 一、查找登录接口 第一次找关于登录接口的时候，一个login都没看到，只看到一个 www.pixiv.net ,可惜是get请求的页面。 在拜读了 Chrome使用技巧 、Chrome开发者工具使用小技巧 后，算是对 chrome 的调试工具有个大概了解的印象，知道了 preserve log 勾选后，可以保留网络日志，于是发现了真正的登录请求 分析参数 password：个人密码 pixiv_id：个人id post_key：不明字符串 source：pc即电脑端（截图没截全，把return_to漏掉了。。。） return_to：是登录成功后跳转的页面，这个可以自己填，貌似默认是 https://www.pixiv.net/ 那么接下来就是找post_key了 首先pixiv非常友好，所以应该不是js加密，而是在页面中随机生成的。 12345# 其次在点击登录的时候就跳转 url1 ↓# url1 = https://accounts.pixiv.net/login?lang=zh&amp;source=pc&amp;view_type=page&amp;ref=wwwtop_accounts_index# 但是登录请求的 url 是 url2 ↓# url2 = https://accounts.pixiv.net/api/login?lang=zh# 所以猜想 post_key 应该是在前者中生成的。 F12 打开，在 Elements 中 Ctrl + F 查看 post_key 接下来用 BeautifulSoup 匹配 12self.post_key = post_key_soup.find('input') ['value'] # 因为是第一个input标签，而find返回的是第一个符合要求的结果 接着向 url2 发去 post 请求 12345678data = &#123; 'pixiv_id': self.pixiv_id, 'password': self.password, 'return_to': self.return_to, 'post_key': self.post_key&#125;rep = se.post(self.login_url, data=data, headers=self.headers,verify=False)# login_url是上面的 url2# 我这里 return_to 写的是个人关注画师的那个页面的 url 登录代码0702更新代码， 123456789101112131415161718192021222324import requestsfrom bs4 import BeautifulSoupse = requests.session()def login(): base_url = 'https://accounts.pixiv.net/login?lang=zh&amp;source=pc&amp;view_type=page&amp;ref=wwwtop_accounts_index' login_url = 'https://accounts.pixiv.net/api/login?lang=zh' headers = &#123; 'referer': 'https://accounts.pixiv.net/login?lang=zh&amp;source=pc&amp;view_type=page&amp;ref=wwwtop_accounts_index', 'origin': 'https://accounts.pixiv.net', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; post_key_html = se.get(base_url) post_key_soup = BeautifulSoup(post_key_html.text, 'lxml') post_key = post_key_soup.find('input')['value'] print(post_key) #捕获postkey data = &#123; 'pixiv_id': 'xxxx', 'password': 'xxxx', 'return_to': 'https://www.pixiv.net/bookmark.php?type=user&amp;rest=show&amp;p=', 'post_key': post_key &#125; rep = se.post(login_url, data=data, headers=headers,verify=False) print(rep.text) 顺便吐槽下 HTTPS 的证书报警问题 12from requests.packages.urllib3.exceptions import InsecureRequestWarning #强制取消警告requests.packages.urllib3.disable_warnings(InsecureRequestWarning) 4、最后 先到这吧，后面继续写解析关注画师页面（页数），寻找数据接口，单图动图多图下载估计写不到了 へ(￣ ￣;へ)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>lxml</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题集成 algolia 站内搜索插件]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Falgolia%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：Next主题集成algolia 一、简述 今天添加并完善了下blog的站内搜索（既然next有集成，为何不用呢？） 主要是参考了几篇超级详细的文章 大赞：Hexo+Next集成Algolia搜索、知乎、hexo-algolia 二、如何更新？123456# 删除 public 文件夹hexo clean# 搜集站点的内容并通过 API 发送给 Algoliahexo algolia# 如遇到 ERROR [Algolia] Please set an `HEXO_ALGOLIA_INDEXING_KEY` environment variable to enable content indexing.# export HEXO_ALGOLIA_INDEXING_KEY=[你的API Key] 三、问题枪毙名单1. Not enough rights to update an object near 解决方法：修改Algolia的ACL访问控制列表 将ACL修改为以上所示，文章里的ACL和现在的界面不一样，不知道是我用得少的原因(雾)，找了几分钟左右。 2. Please provide an Algolia index name in your hexo _config.yml flle 解决方法：修改index名称 index名称就是在以下这个界面输入的那个index name 3. ERROR [Algolia] Please set an HEXO_ALGOLIA_INDEXING_KEY environment variable to enable content indexing. 这个通常是在hexo algolia的时候出现的问题 其实在上面的文章也有说到，这里简单说一下 解决方法： 1export HEXO_ALGOLIA_INDEXING_KEY=[你的API Key] API Key 是 Search-Only API key]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之Xpath]]></title>
    <url>%2Fblog%2F2019%2F03%2F13%2Fxpath%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：Xpath语法，lxml解析html 一、什么是Xpath? XPath 是 XML 路径语言，主要是在 XML 和 HTML 文档中查找我们想要的信息的语言。 XML 和 HTML 一样也是标记语言，但是 XML 用来传输和存储数据，而 HTML 用来显示数据 二、Xpath工具 Google：Xpath Helper （Google 插件可到下载Crx4Chrom(英文)、插件网、Chrome插件网 下载） Firefox：Try Xpath 每个浏览器一般在应用中心或拓展里都可以下载 Xpath Helper 界面 三、Xpath语法1、路径表达式语法、相对/绝对路径 表达式 路径表达式及描述 节点名称 bookstore，选取 bookstore 下的所有子节点(标签) / /bookstore，从根节点下选取所有 bookstore 节点(子元素) // //bookstore，从全局节点中选择 bookstore 节点 @ //div[@price=‘a’]，选择所有 price 属性为 a 的 div . ./input，选择当前节点下的 input 2、谓语html 节点中第一个节点为 1，第二个为 2（需要区分） 表达式 描述 //ul/li[1] 选择 ul 下的第一个 li //ul/li[last()-0] 选择 ul 下的最后一个 li //ul/li[last()-1] 选择 ul 下的倒数第二个 li //ul/li[position()&lt;4] 选择 ul 下前面的 3 个子元素 //ul/li[position()&gt;1] 选择第二个到最后的所有子元素 //li[position()&gt;1] [position()&lt;11] 在(2,+∞)中选择前十个 text() 获取函数文本 @class 获取标签的class 通配符 * /bookstore/*，通配符，匹配 bookstore 下的所有子元素 @* //div[@*]，选择所有带有属性的 div 运算符 “|“ —&gt; //title | //ul[@class=‘item_con_list’]，选择 title 和对应的 ul 四、使用lxml&amp;xpath解析html123456html1 = etree.parse(index.html) # 可以通过读取html文件的方式html2 = etree.HTML(text) # 也可以将字符串解析为HTML文档result1 = etree.tostring(html2) # 将字符串序列化成HTML文档,会自动补全result2 = html2.xpath('表达式') # 使用xpath语法 五、Example 以腾讯招聘网为例 我们要获取到职位名称、职位类别、人数、地点和发布时间等内容 2019.08.23 网站已变化 1//table//tr 选择到了13个子元素，分别是表头，翻页和底部其他招聘 那么可以往上找父元素，扩大范围 1//table[@class='tablelist']//tr[@class='even'] | //table[@class='tablelist']//tr[@class='odd'] 使用以上表达式，避开表头和翻页 上述表达式虽然精确但是有点冗长，鉴于网站规律性，可以采用以下表达式 1//table[@class='tablelist']//tr[position()&gt;1][position()&lt;11] 上面的表达式写在程序里不加text()来取的话，会返回类似 的结果。 123456789101112from lxml import etreeimport requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36'&#125;url = 'https://hr.tencent.com/position.php?lid=2218&amp;start=0#a'html = requests.get(url=url,headers=headers)# html.text未经过编码的字符串，unicode字符串etree_obj = etree.HTML(html.text) # HTML解析的是字符串，所以html.textresult1 = etree_obj.xpath("//table[@class='tablelist']//tr[position()&gt;1][position()&lt;11]//text()")result2 = etree_obj.xpath("//table[@class='tablelist']//tr[position()&gt;1][position()&lt;11]")print(result1)print(result2) 结果可以看到有许多的转义字符，比如：\r、\t 最后将代码处理一下，照此方法可以获取到腾讯招聘的所有职位信息(后面有个坑，比如职位类别是空数据的话，XPath匹配到会自动放弃) 1234567891011121314from lxml import etreeimport requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36'&#125;url = 'https://hr.tencent.com/position.php?lid=2218&amp;start=0#a'html = requests.get(url=url,headers=headers)# html.text未经过编码的字符串，unicode字符串etree_obj = etree.HTML(html.text) # HTML解析的是字符串，所以html.textresult = etree_obj.xpath("//table[@class='tablelist']//tr[position()&gt;1][position()&lt;11]//text()")print(result)result2 = [x.strip() for x in result if x.strip() != '']print(result2)result3 = [print(result2[x],result2[x+1],result2[x+2],result2[x+3],result2[x+4]) for x in range(0,len(result2),5)]print(result3) 结果图 本篇代码Github地址：https://github.com/Coder-Sakura/exp/tree/master/xpath]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2Fgit-note%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：主要记录git的命令和一些git的知识 一、github介绍github(基佬站)是一个开源代码托管平台(其中当然也有私有项目)，也作为一个版本控制系统，让你对代码的版本控制更加简单，不用去担心代码写错了怎么办？有没有备份？专心自己的项目就好。 本文没有关于桌面版的git安装、环境变量配置的教程(安装配置的话百度有很多教程) 二、github功能 可以在上面找到许多开源项目、脚本甚至可以在上面找到一些课程 托管项目。只要连上互联网就可以同步到自己的项目代码或多人跟进项目 利用github和一些开源的博客系统可以搭建个人博客(本博客是hexo+github搭建的) 三、git命令 设置用户名和邮箱，不设置会报“please tell me who you are.”，–global参数表示全局 123git config --global user.name "Your Name" git config --global user.email "email@example.com"git config --list # 检查设置 初始化本地文件夹为git仓库（会生成.git隐藏文件，主要是用于版本控制） 1git init 本地版本管理 123456789101112git add ./[name] # 跟踪文件进入暂存区，.表示当前目录所有文件，也可以指定文件git status # 命令用于显示工作目录和暂存区的状态git commit -m '提交说明' # 将暂存区里的改动给提交到本地的版本库git log --pretty=oneline # 查看最近到最远的提交日志，oneline表示每条输出一行# $ git log --pretty=oneline# f3e98b7f4495c78bf98f2661fad2ae745cd60b63 (HEAD -&gt; master, origin/master) proxy# f3e9....这串就是这次提交的版本号git reset --hard [版本号] # 回退/前进到某个指定版本，版本号可以在git log中找到# 也有快捷的回退命令git reset --hard HEAD^ # 回退到上个版本git reset --hard HEAD^^ # 回退到上上个版本git reset --hard HEAD~100 # 回退到上100个版本 将本地文件提交到github 123456789101112git init git add ./(name) git commit -m 'message'git remote add origin [github仓库地址] # 如果出现错误：fatal: remote origin already exists# 执行 git remote rm origin #删除分支# 再执行 git remote add origin [github仓库地址] #再添加 git push origin master # 推送到github仓库# 如果出现failed to push som refs to…….# 需要将github仓库的文件同步下来先# git pull origin master # pull拉文件下来# 再执行 git push origin master # push推文件上去 四、2019/03/30删除远程仓库的文件，并上传新的文件 12345678910111213# 新建一个文件夹git initgit remote add origin [仓库地址] # git remote rm origingit pull origin master# 然后在本地删除文件git add *git commit -m "del all"git push origin master# 放入新的文件git add *git commit -m "create new file"git push origin master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫之代理]]></title>
    <url>%2Fblog%2F2019%2F02%2F28%2Fproxy%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：代理原理作用，requests设置代理方法以及爬取免费代理的脚本实例 一、代理原理 根据自己理解解读： 客户端设置了代理信息后，客户端向对应的代理站点发出请求（向xxx网站发起请求） 代理站点收到请求之后，就会执行对应的响应动作（执行动作） 代理站点获得xxx网站的响应（得到站点响应） 代理站点根据客户端要求返回对应信息（客户端要求返回Source code，则返回Source code） 二、代理作用 突破自身ip访问限制，比如访问国外站点 爬取对ip访问频率有一定限制的站点 提高访问速度 隐藏真实ip 三、代理网站免费代理ip列表： 含国外ip 方法SEO顾问，89代理，小幻http代理，云代理 不含 西刺，快代理 付费代理尚未了解，此处留空 四、requests设置代理方法requests中有预设好的参数接收代理信息 proxies，这个参数接收的是一个字典对象 因为不知道访问的网站使用的是http协议还是https协议，所以proxies最好2种都有设置 12345proxies = &#123; 'http':92.255.255.78:54628, 'https':92.255.255.78:54628&#125;resp = requests.get(url=url1,headers=headers,proxies=proxies) 五、脚本示例github地址：https://github.com/Coder-Sakura/exp/tree/master/seo_ip 本来我是打算用89代理的api接口，但是测试之后发现可靠性有点低，并且外网ip比较少，所以转用SEO （本次抓取代理ip主要是用在我自己做 pixiv 的小项目上，爬取关注画师的所有作品和自己的收藏作品，后续会整理出来，初学爬虫，有错还请指正） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport randomimport timefrom lxml import etreefrom bs4 import BeautifulSoupfrom requests.packages.urllib3.exceptions import InsecureRequestWarning # 用于强制取消警告from requests.adapters import HTTPAdapter # 用于强制取消警告requests.packages.urllib3.disable_warnings(InsecureRequestWarning) # 强制取消警告class seo_ip(): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; self.agent_ip_list = [] def Agent(self,ip_agent_url): html = requests.get(url=ip_agent_url,headers=self.headers,verify=False,timeout=5) html_soup = BeautifulSoup(html.text, 'lxml') # 去除第一个和前25个，26-50为国外ip ip_list = html_soup.find('tbody').find_all('tr')[26:] items = [] print('搜索完成,代理信息如下:') for item in ip_list: ip_port = list(item)[0].get_text() + ':' +list(item)[1].get_text() # list(ip_port)[0]为ip,[1]为端口,[2]响应时间,[3]位置,[4]最后验证时间 print('ip: %s ,响应时间: %ss ,ip位置: %s' % (ip_port,list(item)[2].get_text(),list(item)[3].get_text())) items.append(ip_port) #存储爬取到的ip(需要添加) return items def judge(self,items): # 检验ip活性 # https://ip.seofangfa.com/ print('正在进行代理池ip活性检测......') for item in items: try: proxy = &#123; 'http':item, 'https':item &#125; # 遍历时，利用百度，设定timeout，未响应则断开连接 judge_url = 'https://www.baidu.com/' response = requests.get(url=judge_url,headers=self.headers,proxies=proxy,verify=False,timeout=5) self.agent_ip_list.append(item) print(item,'可用...') except: print(item,'不可用...') print('代理池ip活性检测完毕...\n代理池总量:',len(self.agent_ip_list),'\n代理池:',self.agent_ip_list) def work(self): ip_agent_url = 'https://ip.seofangfa.com/' items = self.Agent(ip_agent_url) self.judge(items)seo_ip = seo_ip()seo_ip.work() 没有导入这2个库的话，会因为ssl证书而出现警告，如图： from requests.packages.urllib3.exceptions import InsecureRequestWarning from requests.adapters import HTTPAdapter 六、附图 最后附上运行图]]></content>
      <categories>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python第三方库安装[pip、whl]]]></title>
    <url>%2Fblog%2F2019%2F02%2F12%2F212%2F</url>
    <content type="text"><![CDATA[说在前面的话本篇概述：python第三方库安装 一、pip安装 pip3 install [库名] 或 pip install [库名] [2019.02.28更新] 针对 ‘pip’ 不是内部命令，也不是可运行的程序的情况： 原因：环境变量 Path 未配置完成 找到 python 的安装目录，将 python 的安装目录 和 Python安装目录\Scripts 添加到 环境变量 Path 中即可； 环境变量Path：计算机属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量 二、whl安装点我可以将内容伸缩哦~ ٩(๑&gt;◡&lt;๑)۶ 如果pip安装不行，可以考虑whl安装(轮子大法好！) Python常用库whl文件下载 如何知道本机安装的python支持哪个版本的轮子? 首先要知道系统是多少位的？(在cmd中输入)1systeminfo | findstr "系统类型" 结果：x64-based PC = (64位 AMD64) 12import pip._internalprint(pip._internal.pep425tags.get_supported()) X86-based PC = (32位 WIN32) 12import pipprint(pip.pep425tags.get_supported()) 选择对应的轮子 输入上面的代码后，会返回一个list，list里面就是当前系统支持的whl版本 比如 ‘cp37’, ‘cp37m’, ‘win_amd64’，cp37对应的是python3.7版本; cp37m 对应的是依赖于python3.7应用程序二进制接口; win_amd64对应的是64位系统编译的。 打开上面的网址，ctrl + F ，这里使用 mysqlclient 作为示范 根据刚刚的结果，下载以下版本的轮子即可。 mysqlclient‑1.4.2‑cp37‑cp37m‑win_amd64.whl ​ 库名 - 版本号 - 对应python版本 - 依赖 - 系统位数 安装轮子 进入到轮子目录，cmd打开，pip install [名字].whl 即可 [2019.02.28更新] 针对 pip install [名字].whl 安装不成功的情况 可以将whl文件的后缀名.whl更改为.zip，然后解压 在解压目录下进行 python setup.py install 运行安装[通常whl文件解压后都有setup.py] 对于没有 setup.py 的，直接将解压目录放入libs文件夹中 whl文件是已经编译好的文件，作用主要是为了方便我们进行 python 的第三方库安装和使用 三、Anaconda​ Anaconda包括Conda、Python以及一大堆安装好的科学包和依赖项。(Conda是一个开源的包和环境的管理器) ​ 从 Anaconda官网 下载，图形化安装，十分简单，而且网上的教程也多。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
